!--------------------------------------------------------------------------
! This is free software, you can use/redistribute/modify it under the terms of
! the EC-RPN License v2 or any later version found (if not provided) at:
! - http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html
! - EC-RPN License, 2121 TransCanada, suite 500, Dorval (Qc), CANADA, H9P 1J3
! - service.rpn@ec.gc.ca
! It is distributed WITHOUT ANY WARRANTY of FITNESS FOR ANY PARTICULAR PURPOSE.
!--------------------------------------------------------------------------
!@author Stephane Chamberland <stephane.chamberland@ec.gc.ca>, 2009-10

#include "scrip.h"


module scrip_init_var
   implicit none
   save
   logical :: isInit = .false.
   logical :: hasGrid1LatLon = .false.
   logical :: hasGrid2LatLon = .false.
   logical :: ownLatLon1Mem = .false.
   logical :: ownLatLon2Mem = .false.
end module scrip_init_var


!/**
function scrip_init_options( &
     F_num_srch_bins, F_map_method, &
     F_normalize_opt, F_restrict_type,F_nb_maps) result(errorCode)
   use scrip_init_var
   use kinds_mod
   use grids
   use remap_vars
   implicit none
!**/
   integer (kind=int_kind) :: &
        F_num_srch_bins, &  ! num of bins for restricted srch
        F_nb_maps,       &  ! num of remappings for this grid pair
        F_map_method,    &  ! choice for mapping method
        F_normalize_opt, &  ! option for normalizing weights
        F_restrict_type     ! type of bins to use
   integer :: errorCode
   !--------------------------------------------------
   if (isInit) then
      errorCode = SCRIP_ERROR
      return
   endif
   errorCode = SCRIP_OK
   isInit = .true.
   hasGrid1LatLon = .false.
   hasGrid2LatLon = .false.
   ownLatLon1Mem = .false.
   ownLatLon2Mem = .false.
   luse_grid1_area = .false. !TODO: remove this restriction
   luse_grid2_area = .false. !TODO: remove this restriction
   num_maps      = 1
   map_type      = 1
   restrict_type = 'latitude'
   num_srch_bins = 900

   if (F_nb_maps>0)           num_maps      = F_nb_maps
   if (F_num_srch_bins>0)     num_srch_bins = F_num_srch_bins
   if (F_restrict_type==SCRIP_RESTRICT_LALO) restrict_type = 'latlon'

   select case(F_map_method)
   case (SCRIP_CONSERVATIVE)
      map_type = map_type_conserv
      luse_grid_centers = .false.
   case (SCRIP_BILINEAR)
      map_type = map_type_bilinear
      luse_grid_centers = .true.
   case (SCRIP_BICUBIC)
      map_type = map_type_bicubic
      luse_grid_centers = .true.
   case default !SCRIP_DISTWGT
      map_type = map_type_distwgt
      luse_grid_centers = .true.
   end select

   select case(F_normalize_opt)
   case (SCRIP_NORM_NONE)
      norm_opt = norm_opt_none
   case (SCRIP_NORM_DESTAREA)
      norm_opt = norm_opt_dstarea
   case default !SCRIP_NORM_FRACAREA
      norm_opt = norm_opt_frcarea
   end select
   !--------------------------------------------------
   return
end function scrip_init_options


!/**
function scrip_set_grid_latlon_rad( &
     F_grid_nb,F_grid_size,F_grid_dims,F_grid_nb_corners,&
     F_grid_center_lat,F_grid_center_lon, &
     F_grid_corner_lat,F_grid_corner_lon) result(errorCode)
   use scrip_init_var
   use kinds_mod
   use grids
   implicit none
   integer (kind=int_kind), dimension(2) :: &
        F_grid_dims ! size of each grid dimension
   integer (kind=int_kind) :: &
        F_grid_nb,F_grid_size, &
        F_grid_nb_corners ! number of corners for each grid cell
   real (kind=real_kind), dimension(F_grid_size), target :: &
        F_grid_center_lat, & ! lat/lon coordinates for
        F_grid_center_lon    ! each grid center in radians
   real (kind=real_kind), dimension(F_grid_nb_corners,F_grid_size), target :: &
        F_grid_corner_lat, & ! lat/lon coordinates for
        F_grid_corner_lon    ! each grid corner in radians
   integer :: errorCode,iStat
   !IMPORTANT: Lat,Lon must be given in Radiants
!**/
   !--------------------------------------------------
   errorCode = SCRIP_ERROR
   if (F_grid_nb == SCRIP_INPUT_GRID) then
      if (hasGrid1LatLon) return
      errorCode = SCRIP_OK
      hasGrid1LatLon = .true.
      ownLatLon1Mem = .true.
      grid1_size = F_grid_size
      grid1_corners = F_grid_nb_corners
      grid1_rank = 2
      if (F_grid_dims(1)==1 .or. F_grid_dims(1)==grid1_size) grid1_rank = 1
      allocate(grid1_dims(2))
      grid1_dims = F_grid_dims
      allocate(grid1_center_lat(F_grid_size),STAT=istat)
      allocate(grid1_center_lon(F_grid_size),STAT=istat)
      allocate(grid1_corner_lat(F_grid_nb_corners,F_grid_size),STAT=istat)
      allocate(grid1_corner_lon(F_grid_nb_corners,F_grid_size),STAT=istat)
      grid1_center_lat = dble(F_grid_center_lat)
      grid1_center_lon = dble(F_grid_center_lon)
      grid1_corner_lat = dble(F_grid_corner_lat)
      grid1_corner_lon = dble(F_grid_corner_lon)
      allocate(grid1_mask(grid1_size))
      grid1_mask = .true.
   else !if (F_grid_nb == SCRIP_OUTPUT_GRID)
      if (hasGrid2LatLon) return
      errorCode = SCRIP_OK
      hasGrid2LatLon = .true.
      ownLatLon2Mem = .true.
      grid2_size = F_grid_size
      grid2_corners = F_grid_nb_corners
      grid2_rank = 2
      if (F_grid_dims(1)==1 .or. F_grid_dims(1)==grid2_size) grid2_rank = 1
      allocate(grid2_dims(2))
      grid2_dims = F_grid_dims
      allocate(grid2_center_lat(F_grid_size),STAT=istat)
      allocate(grid2_center_lon(F_grid_size),STAT=istat)
      allocate(grid2_corner_lat(F_grid_nb_corners,F_grid_size),STAT=istat)
      allocate(grid2_corner_lon(F_grid_nb_corners,F_grid_size),STAT=istat)
      grid2_center_lat = dble(F_grid_center_lat)
      grid2_center_lon = dble(F_grid_center_lon)
      grid2_corner_lat = dble(F_grid_corner_lat)
      grid2_corner_lon = dble(F_grid_corner_lon)
      allocate(grid2_mask(grid2_size))
      grid2_mask = .true.
   endif
   !--------------------------------------------------
   return
end function scrip_set_grid_latlon_rad


!/**
function scrip_set_grid_latlon_rad_8( &
     F_grid_nb,F_grid_size,F_grid_dims,F_grid_nb_corners,&
     F_grid_center_lat,F_grid_center_lon, &
     F_grid_corner_lat,F_grid_corner_lon) result(errorCode)
   use scrip_init_var
   use kinds_mod
   use grids
   implicit none
   integer (kind=int_kind), dimension(2) :: &
        F_grid_dims ! size of each grid dimension
   integer (kind=int_kind) :: &
        F_grid_nb,F_grid_size, &
        F_grid_nb_corners ! number of corners for each grid cell
   real (kind=dbl_kind), dimension(F_grid_size), target :: &
        F_grid_center_lat, & ! lat/lon coordinates for
        F_grid_center_lon    ! each grid center in radians
   real (kind=dbl_kind), dimension(F_grid_nb_corners,F_grid_size), target :: &
        F_grid_corner_lat, & ! lat/lon coordinates for
        F_grid_corner_lon    ! each grid corner in radians
   integer :: errorCode
   !IMPORTANT: Lat,Lon must be given in Radiants
!**/
   !--------------------------------------------------
   errorCode = SCRIP_ERROR
   if (F_grid_nb == SCRIP_INPUT_GRID) then
      if (hasGrid1LatLon) return
      errorCode = SCRIP_OK
      hasGrid1LatLon = .true.
      grid1_size = F_grid_size
      grid1_corners = F_grid_nb_corners
      grid1_rank = 2
      if (F_grid_dims(1)==1 .or. F_grid_dims(1)==grid1_size) grid1_rank = 1
      allocate(grid1_dims(2))
      grid1_dims = F_grid_dims
      grid1_center_lat => F_grid_center_lat
      grid1_center_lon => F_grid_center_lon
      grid1_corner_lat => F_grid_corner_lat
      grid1_corner_lon => F_grid_corner_lon
      allocate(grid1_mask(grid1_size))
      grid1_mask = .true.
   else !if (F_grid_nb == SCRIP_OUTPUT_GRID)
      if (hasGrid2LatLon) return
      errorCode = SCRIP_OK
      hasGrid2LatLon = .true.
      grid2_size = F_grid_size
      grid2_corners = F_grid_nb_corners
      grid2_rank = 2
      if (F_grid_dims(1)==1 .or. F_grid_dims(1)==grid2_size) grid2_rank = 1
      allocate(grid2_dims(2))
      grid2_dims = F_grid_dims
      grid2_center_lat => F_grid_center_lat
      grid2_center_lon => F_grid_center_lon
      grid2_corner_lat => F_grid_corner_lat
      grid2_corner_lon => F_grid_corner_lon
      allocate(grid2_mask(grid2_size))
      grid2_mask = .true.
   endif
   !--------------------------------------------------
   return
end function scrip_set_grid_latlon_rad_8


!/**
function scrip_set_grid_mask(F_grid_nb,F_grid_size,F_grid_mask) result(errorCode)
   use scrip_init_var
   use kinds_mod
   use grids
   implicit none
   integer :: errorCode
   integer (kind=int_kind) :: F_grid_nb,F_grid_size
   integer (kind=int_kind), dimension(F_grid_size) :: F_grid_mask
!**/
   !--------------------------------------------------
   errorCode = SCRIP_ERROR
   if (F_grid_nb==SCRIP_INPUT_GRID .and. hasGrid1LatLon .and. F_grid_size==grid1_size) then
         errorCode = SCRIP_OK
         where (F_grid_mask == 1)
            grid1_mask = .true.
         elsewhere
            grid1_mask = .false.
         endwhere
   else if (hasGrid2LatLon .and. F_grid_size==grid2_size) then
      errorCode = SCRIP_OK
      where (F_grid_mask == 1)
         grid2_mask = .true.
      elsewhere
         grid2_mask = .false.
      endwhere
   endif
   !--------------------------------------------------
   return
end function scrip_set_grid_mask


!/**
function scrip_compute_addr_wts() result(errorCode)
   use scrip_init_var
   implicit none
   integer :: errorCode
!**/
   !--------------------------------------------------
   errorCode = SCRIP_ERROR
   if (isInit .and. hasGrid1LatLon .and. hasGrid2LatLon) then
      errorCode = SCRIP_OK
      call scrip_addr_wts()
      call scrip_deallocate_work_array()
   endif
   !--------------------------------------------------
   return
end function scrip_compute_addr_wts


!/**
subroutine scrip_get_dims(F_map_nb,F_num_wts,F_num_links)
   use kinds_mod
   use remap_vars
   implicit none
   integer (kind=int_kind) :: F_map_nb               !in
   integer (kind=int_kind) :: F_num_wts, F_num_links !out
!**/
   integer,external :: scrip_is_addr_wts_avail
   !--------------------------------------------------
   F_num_wts = 0
   F_num_links = 0
   if (scrip_is_addr_wts_avail(F_map_nb) == SCRIP_OK) then
      if (F_map_nb == SCRIP_MAPPING_FORWARD) then
         F_num_links = SIZE(grid2_add_map1)
         F_num_wts   = SIZE(wts_map1, DIM=1)
      else !if (F_map_nb == SCRIP_MAPPING_REVERSE)
         F_num_links = SIZE(grid2_add_map2)
         F_num_wts   = SIZE(wts_map2, DIM=1)
      endif
   endif
   !--------------------------------------------------
   return
end subroutine scrip_get_dims


!/**
function scrip_is_addr_wts_avail(F_map_nb) result(errorCode)
   use kinds_mod
   use remap_vars
   implicit none
   integer (kind=int_kind) :: F_map_nb !in
   integer (kind=int_kind) :: errorCode
!**/
   !--------------------------------------------------
   errorCode = SCRIP_ERROR
   if (F_map_nb == SCRIP_MAPPING_FORWARD) then
      if (allocated(grid1_add_map1) .and. &
           allocated(grid2_add_map1) .and. &
           allocated(wts_map1)) &
           errorCode = SCRIP_OK
   else !if (F_map_nb == SCRIP_MAPPING_REVERSE)
      if (allocated(grid1_add_map2) .and. &
           allocated(grid2_add_map2) .and. &
           allocated(wts_map2)) &
           errorCode = SCRIP_OK
   endif
   !--------------------------------------------------
   return
end function scrip_is_addr_wts_avail


!/**
subroutine scrip_get_addr_wts_8(F_map_nb,F_num_wts, F_num_links, &
     F_grid1_add_map, F_grid2_add_map, F_wts_map, &
     errorCode)
   use kinds_mod
   use remap_vars
   implicit none
   integer (kind=int_kind) :: F_num_wts, F_num_links,F_map_nb !in
   integer (kind=int_kind), dimension(F_num_links) :: &
        F_grid1_add_map, & ! out, grid1 address for each link in mapping 1
        F_grid2_add_map    ! out, grid2 address for each link in mapping 1
   real (kind=dbl_kind), dimension(F_num_wts, F_num_links) :: &
        F_wts_map          ! out, map weights for each link(num_wts,max_links)
   integer (kind=int_kind) :: errorCode ! out
!**/
   integer :: n,nw
   integer, external :: scrip_is_addr_wts_avail
   !--------------------------------------------------
   !TODO: get_addr_wts for map2
   errorCode = SCRIP_ERROR
   if (scrip_is_addr_wts_avail(F_map_nb) == SCRIP_ERROR) then
      return
   endif
   if (F_map_nb == SCRIP_MAPPING_FORWARD) then
      n  = min(F_num_links,SIZE(grid1_add_map1),SIZE(grid2_add_map1))
      nw = min(F_num_wts,SIZE(wts_map1, DIM=1))
      if (n == F_num_links .and. nw == F_num_wts) then
         errorCode = SCRIP_OK
         F_grid1_add_map(1:n) = grid1_add_map1(1:n)
         F_grid2_add_map(1:n) = grid2_add_map1(1:n)
         F_wts_map(1:nw,1:n) = wts_map1(1:nw,1:n)
      endif
   else !if (F_map_nb == SCRIP_MAPPING_REVERSE)
      n = min(F_num_links,SIZE(grid1_add_map2),SIZE(grid2_add_map2))
      nw = min(F_num_wts,SIZE(wts_map2, DIM=1))
      if (n == F_num_links .and. nw == F_num_wts) then
         errorCode = SCRIP_OK
         F_grid1_add_map(1:n) = grid1_add_map2(1:n)
         F_grid2_add_map(1:n) = grid2_add_map2(1:n)
         F_wts_map(1:nw,1:n) = wts_map2(1:nw,1:n)
      endif
   endif
   !--------------------------------------------------
   return
end subroutine scrip_get_addr_wts_8


!/**
subroutine scrip_finalize()
   use scrip_init_var
   use grids
   use remap_vars
   implicit none
!**/
   !--------------------------------------------------
   if (allocated(grid1_add_map1)) deallocate(grid1_add_map1)
   if (allocated(grid2_add_map1)) deallocate(grid2_add_map1)
   if (allocated(wts_map1)) deallocate(wts_map1)
   if (allocated(grid1_add_map2)) deallocate(grid1_add_map2)
   if (allocated(grid2_add_map2)) deallocate(grid2_add_map2)
   if (allocated(wts_map2)) deallocate(wts_map2)
   call scrip_deallocate_work_array()
   if (ownLatLon1Mem) then
      if (associated(grid1_center_lat)) deallocate(grid1_center_lat)
      if (associated(grid1_center_lon)) deallocate(grid1_center_lon)
      if (associated(grid1_corner_lat)) deallocate(grid1_corner_lat)
      if (associated(grid1_corner_lon)) deallocate(grid1_corner_lon)
   endif
   if (ownLatLon2Mem) then
      if (associated(grid2_center_lat)) deallocate(grid2_center_lat)
      if (associated(grid2_center_lon)) deallocate(grid2_center_lon)
      if (associated(grid2_corner_lat)) deallocate(grid2_corner_lat)
      if (associated(grid2_corner_lon)) deallocate(grid2_corner_lon)
   endif
   isInit = .false.
   hasGrid1LatLon = .false.
   hasGrid2LatLon = .false.
   ownLatLon1Mem = .false.
   ownLatLon2Mem = .false.
   !--------------------------------------------------
   return
end subroutine scrip_finalize


!/**
subroutine scrip_deallocate_work_array()
   use scrip_init_var
   use grids
   use remap_vars
   implicit none
!**/
   !--------------------------------------------------
   if (allocated(grid1_dims)) deallocate(grid1_dims)
   if (allocated(grid1_mask)) deallocate(grid1_mask)
   if (allocated(grid1_area)) deallocate(grid1_area)
   if (allocated(grid1_frac)) deallocate(grid1_frac)
   if (allocated(grid1_bound_box)) deallocate(grid1_bound_box)
   if (allocated(grid2_dims)) deallocate(grid2_dims)
   if (allocated(grid2_mask)) deallocate(grid2_mask)
   if (allocated(grid2_area)) deallocate(grid2_area)
   if (allocated(grid2_frac)) deallocate(grid2_frac)
   if (allocated(grid2_bound_box)) deallocate(grid2_bound_box)
   if (allocated(bin_addr1)) deallocate(bin_addr1)
   if (allocated(bin_addr2)) deallocate(bin_addr2)
   if (allocated(bin_lats)) deallocate(bin_lats)
   if (allocated(bin_lons)) deallocate(bin_lons)
   !--------------------------------------------------
   return
end subroutine scrip_deallocate_work_array


!/**
subroutine scrip_interpol_o1(dst_array, src_array, &
     dst_add, src_add, map_wts, &
     nwts,nlinks,dst_size,src_size)
   use kinds_mod
   use remap_mod
   implicit none
   integer :: nwts,nlinks,dst_size,src_size
   integer (kind=int_kind), dimension(nlinks):: &
        dst_add,    & ! destination address for each link
        src_add      ! source      address for each link

   real (kind=dbl_kind), dimension(nwts,nlinks):: &
        map_wts      ! remapping weights for each link

   real (kind=real_kind), dimension(src_size):: &
        src_array    ! array with source field to be remapped

   real (kind=real_kind), dimension(dst_size) :: &
        dst_array    ! array for remapped field on destination grid
!**/
   integer :: n
   !---------------------------------------------------------------
   dst_array = 0.
   do n=1,nlinks
      dst_array(dst_add(n)) = real(dble(dst_array(dst_add(n))) + &
           dble(src_array(src_add(n)))*map_wts(1,n))
   enddo
   !---------------------------------------------------------------
   return
end subroutine scrip_interpol_o1


!/**
subroutine scrip_interpol_o1_8(dst_array, src_array, &
     dst_add, src_add, map_wts, &
     nwts,nlinks,dst_size,src_size)
   use kinds_mod
   use remap_mod
   implicit none
   integer :: nwts,nlinks,dst_size,src_size
   integer (kind=int_kind), dimension(nlinks):: &
        dst_add,    & ! destination address for each link
        src_add      ! source      address for each link

   real (kind=dbl_kind), dimension(nwts,nlinks):: &
        map_wts      ! remapping weights for each link

   real (kind=dbl_kind), dimension(src_size):: &
        src_array    ! array with source field to be remapped

   real (kind=dbl_kind), dimension(dst_size) :: &
        dst_array    ! array for remapped field on destination grid
!**/
   integer :: n
   !---------------------------------------------------------------
   dst_array = 0.D0
   do n=1,nlinks
      dst_array(dst_add(n)) = dst_array(dst_add(n)) + &
           src_array(src_add(n))*map_wts(1,n)
   enddo
   !---------------------------------------------------------------
   return
end subroutine scrip_interpol_o1_8



!!$!/**
!!$module scrip_interface
!!$   use kinds_mod
!!$   use remap_vars
!!$   use scrip_init_var
!!$   implicit None
!!$   private
!!$   public :: scrip_get_addr_wts
!!$!**/
!!$
!!$contains
!!$
!!$   !/**
!!$   function scrip_get_addr_wts(F_map_nb,F_grid1_add_map, F_grid2_add_map, F_wts_map) result(errorCode)
!!$      implicit none
!!$      integer :: F_map_nb,errorCode
!!$      integer(kind=int_kind), pointer, dimension(:) :: &
!!$           F_grid1_add_map, & ! out, grid1 address for each link in mapping 1
!!$           F_grid2_add_map    ! out, grid2 address for each link in mapping 1
!!$      real(kind=dbl_kind), pointer, dimension(:, :) :: &
!!$           F_wts_map          ! out, map weights for each link(num_wts,max_links)
!!$      integer, external :: scrip_is_addr_wts_avail
!!$   !**/
!!$      !--------------------------------------------------
!!$      errorCode = SCRIP_ERROR
!!$      if (isInit .and. hasGrid1LatLon .and. hasGrid2LatLon) then
!!$         call scrip_addr_wts()
!!$         if (scrip_is_addr_wts_avail(F_map_nb) ==  SCRIP_OK) then
!!$            if (F_map_nb == 1) then
!!$               F_grid1_add_map => grid1_add_map1
!!$               F_grid2_add_map => grid2_add_map1
!!$               F_wts_map => wts_map1
!!$            else
!!$               F_grid1_add_map => grid1_add_map2
!!$               F_grid2_add_map => grid2_add_map2
!!$               F_wts_map => wts_map2
!!$            endif
!!$            errorCode = SCRIP_OK
!!$         endif
!!$         call scrip_deallocate_work_array()
!!$      endif
!!$      !--------------------------------------------------
!!$      return
!!$   end function scrip_get_addr_wts
!!$
!!$end module scrip_interface
