!--------------------------------------------------------------------------
! This is free software, you can use/redistribute/modify it under the terms of
! the EC-RPN License v2 or any later version found (if not provided) at:
! - http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html
! - EC-RPN License, 2121 TransCanada, suite 500, Dorval (Qc), CANADA, H9P 1J3
! - service.rpn@ec.gc.ca
! It is distributed WITHOUT ANY WARRANTY of FITNESS FOR ANY PARTICULAR PURPOSE.
!--------------------------------------------------------------------------
!@author Stephane Chamberland <stephane.chamberland@ec.gc.ca>, 2009-10

#include "scrip.h"

#define RDOUBLE 8
!/**
program scrip_interp_test
   use kinds_mod
   implicit none
!**/
   integer, parameter :: NB_CORNERS = 4
   integer, parameter :: NB_SCRIP_BINS = 100
   integer, parameter :: NB_DELTA = 8
   integer :: niIn,njIn,niOut,njOut,nbWeights,nbAddr ,iErr,istat
   real    :: dlaloIn,dlaloOut,radPerDeg,degPerRad
   integer, dimension(2) :: dimsGridIn, dimsGridOut
   real, dimension(:,:),   allocatable :: gridInCenterLat,gridInCenterLon
   real, dimension(:,:,:), allocatable :: gridInCornersLat,gridInCornersLon
   real, dimension(:,:),   allocatable :: gridOutCenterLat,gridOutCenterLon
   real, dimension(:,:,:), allocatable :: gridOutCornersLat,gridOutCornersLon
   real(dbl_kind), dimension(:,:), pointer :: interpWeights
   integer, dimension(:), pointer :: PointAddrGridIn,PointAddrGridOut
   real, dimension(:,:),   allocatable :: gridOutCenterLat2
   integer, external :: scrip_init_options,scrip_set_grid_latlon_rad,scrip_compute_addr_wts
   integer :: i,j,k,nbErrPoints(NB_DELTA)
   real :: delta(NB_DELTA),relErr
   !---------------------------------------------------------------------
   niIn    = 13
   njIn    = 11
   dlaloIn = 0.5
   dimsGridIn(1) = niIn
   dimsGridIn(2) = njIn

   niOut   = niIn + 3
   njOut   = njIn + 1
!!$   niOut   = 19
!!$   njOut   = 21
   dlaloOut= 0.25
   dimsGridOut(1) = niOut
   dimsGridOut(2) = njOut

   radPerDeg = cos(-1.)/180.
   degPerRad = 180./cos(-1.)

   allocate(gridInCenterLat(niIn,njIn),STAT=istat)
   allocate(gridInCenterLon(niIn,njIn),STAT=istat)
   allocate(gridInCornersLat(NB_CORNERS,niIn,njIn),STAT=istat)
   allocate(gridInCornersLon(NB_CORNERS,niIn,njIn),STAT=istat)
   allocate(gridOutCenterLat(niOut,njOut),STAT=istat)
   allocate(gridOutCenterLon(niOut,njOut),STAT=istat)
   allocate(gridOutCornersLat(NB_CORNERS,niOut,njOut),STAT=istat)
   allocate(gridOutCornersLon(NB_CORNERS,niOut,njOut),STAT=istat)

   call getLatLon(gridInCenterLat,gridInCenterLon,gridInCornersLat,gridInCornersLon,dlaloIn,niIn,njIn)
   call getLatLon(gridOutCenterLat,gridOutCenterLon,gridOutCornersLat,gridOutCornersLon,dlaloOut,niOut,njOut)

   gridInCenterLat   = gridInCenterLat * radPerDeg
   gridInCenterLon   = gridInCenterLon * radPerDeg
   gridInCornersLat  = gridInCornersLat * radPerDeg
   gridInCornersLon  = gridInCornersLon * radPerDeg
   gridOutCenterLat  = gridOutCenterLat * radPerDeg
   gridOutCenterLon  = gridOutCenterLon * radPerDeg
   gridOutCornersLat = gridOutCornersLat * radPerDeg
   gridOutCornersLon = gridOutCornersLon * radPerDeg

   iErr = scrip_init_options(NB_SCRIP_BINS, SCRIP_DISTWGT, &
        SCRIP_NORM_FRACAREA, SCRIP_RESTRICT_LAT, SCRIP_REMAP_ONEWAY)

   iErr = scrip_set_grid_latlon_rad(SCRIP_INPUT_GRID, niIn*njIn, dimsGridIn, NB_CORNERS,&
        gridInCenterLat, gridInCenterLon, gridInCornersLat, gridInCornersLon)

   iErr = scrip_set_grid_latlon_rad(SCRIP_OUTPUT_GRID, niOut*njOut, dimsGridOut, NB_CORNERS,&
        gridOutCenterLat, gridOutCenterLon, gridOutCornersLat,gridOutCornersLon)

   !Using default mask (all=1)
   !iErr = scrip_set_grid_mask(SCRIP_INPUT_GRID,niIn*njIn,gridInMask)
   !iErr = scrip_set_grid_mask(SCRIP_OUTPUT_GRID,niOut*njOut,gridOutMask)

   iErr = scrip_compute_addr_wts()

   deallocate(gridInCenterLon,STAT=istat)
   deallocate(gridInCornersLat,STAT=istat)
   deallocate(gridInCornersLon,STAT=istat)
   deallocate(gridOutCenterLon,STAT=istat)
   deallocate(gridOutCornersLat,STAT=istat)
   deallocate(gridOutCornersLon,STAT=istat)

   call scrip_get_dims(SCRIP_MAPPING_FORWARD,nbWeights,nbAddr)
   if (nbWeights<1 .or. nbAddr<1) then
      print *,'Scrip test error: nbWeights<1 .or. nbAddr<1 :',nbWeights,nbAddr
      stop
   endif

   allocate(PointAddrGridIn(nbAddr),STAT=istat)
   allocate(PointAddrGridOut(nbAddr),STAT=istat)
   allocate(interpWeights(nbWeights,nbAddr),STAT=istat)

   call scrip_get_addr_wts_8(SCRIP_MAPPING_FORWARD,nbWeights,nbAddr, &
        PointAddrGridIn,PointAddrGridOut,interpWeights, &
        iErr)
   if (iErr == SCRIP_ERROR) then
      print *,'Scrip test error in scrip_get_addr_wts'
      stop
   endif
   
   print *,'PointAddrGridIn',minval(PointAddrGridIn),maxval(PointAddrGridIn), '<=',niIn*njIn
   print *,'PointAddrGridOut',minval(PointAddrGridOut),maxval(PointAddrGridOut), '<=',niOut*njOut
   print *,'interpWeights',minval(interpWeights),maxval(interpWeights)
!!$   print *,interpWeights

   call scrip_finalize()

   allocate(gridOutCenterLat2(niOut,njOut),STAT=istat)

   gridInCenterLat  = (gridInCenterLat  * degPerRad * 10.) + 5.
   gridOutCenterLat = (gridOutCenterLat * degPerRad * 10.) + 5.

   call scrip_interpol_o1(gridOutCenterLat2, gridInCenterLat, &
        PointAddrGridOut,PointAddrGridIn,interpWeights, &
        nbWeights,nbAddr,size(gridOutCenterLat2),size(gridInCenterLat))

   print *,'gridOutCenterLat2',minval(gridOutCenterLat2),maxval(gridOutCenterLat2)

   !delta = 1.e-5
   nbErrPoints = 0
   delta(1) = 1.
   do k =2,NB_DELTA
      delta(k) = delta(k-1)/10.
   enddo

   do j=1,njOut
      do i=1,niOut
         relErr = (gridOutCenterLat2(i,j)-gridOutCenterLat(i,j))/gridOutCenterLat2(i,j)
         if (abs(relErr)>delta(1)) then
            print '(2I4,X,2F6.2,X,F7.1,A)',i,j,gridOutCenterLat(i,j),gridOutCenterLat2(i,j),100.*relErr &
                 ,'%'
            nbErrPoints(1) = nbErrPoints(1) + 1
         endif
         do k=2,NB_DELTA
            if (abs(relErr)>delta(k)) nbErrPoints(k) = nbErrPoints(k) + 1
         enddo
      enddo
   enddo

   do k=1,NB_DELTA
      print '(a,F5.1,a,F10.5,a)','There are ',100.*float(nbErrPoints(k))/float(niOut*njOut),'% of point with RelErr>',100.*delta(k),'%'
   enddo
   print '(a,F5.1,a,F10.5,a)','There are ',100.*(1.- float(nbErrPoints(NB_DELTA))/float(niOut*njOut)),'% of point with RelErr<',100.*delta(NB_DELTA),'%'

   deallocate(gridInCenterLat,STAT=istat)
   deallocate(gridOutCenterLat,STAT=istat)
   deallocate(gridOutCenterLat2,STAT=istat)
   !---------------------------------------------------------------------
end program scrip_interp_test


!/**
subroutine getLatLon(centerLat,centerLon,cornersLat,cornersLon,dlalo,ni,nj)
   implicit none
   integer , parameter :: NB_CORNERS = 4
   integer :: ni,nj
   real :: dlalo
   real, dimension(ni,nj)   :: centerLat,centerLon
   real, dimension(NB_CORNERS,ni,nj) :: cornersLat,cornersLon
!**/
   integer :: gridId, iErr,istat
   real, dimension(:,:),   allocatable :: centerXpos,centerYpos
   real, dimension(:,:,:), allocatable :: cornersXpos,cornersYpos
   integer, external :: getGridId,gdll,gdxyfll,gdllfxy,get_corners_xy
   !---------------------------------------------------------------------
   gridId = getGridId(dlalo,ni,nj)
   
   allocate(centerXpos(ni,nj),STAT=istat)
   allocate(centerYpos(ni,nj),STAT=istat)
   allocate(cornersXpos(NB_CORNERS,ni,nj),STAT=istat)
   allocate(cornersYpos(NB_CORNERS,ni,nj),STAT=istat)

   iErr = gdll(gridId,centerLat,centerLon)
   if (iErr<0) print *,'Error: gdll'
   iErr = gdxyfll(gridId,centerXpos,centerYpos,centerLat,centerLon,ni*nj)
   if (iErr<0) print *,'Error: gdxyfll'
   iErr = get_corners_xy(cornersXpos,cornersYpos,centerXpos,centerYpos,ni,nj)
   if (iErr<0) print *,'Error: get_corners_xy'
   iErr = gdllfxy(gridId,cornersLat,cornersLon,cornersXpos,cornersYpos,ni*nj*NB_CORNERS)
   if (iErr<0) print *,'Error: gdllfxy'

!!$   print *,'centerLat',minval(centerLat),maxval(centerLat)
!!$   print *,'centerLon',minval(centerLon),maxval(centerLon)
!!$   print *,'centerXpos',minval(centerXpos),maxval(centerXpos)
!!$   print *,'centerYpos',minval(centerYpos),maxval(centerYpos)
!!$   print *,'cornersXpos',minval(cornersXpos),maxval(cornersXpos)
!!$   print *,'cornersYpos',minval(cornersYpos),maxval(cornersYpos)
!!$   print *,'cornersLat',minval(cornersLat),maxval(cornersLat)
!!$   print *,'cornersLon',minval(cornersLon),maxval(cornersLon)

   deallocate(centerXpos,STAT=istat)
   deallocate(centerYpos,STAT=istat)
   deallocate(cornersXpos,STAT=istat)
   deallocate(cornersYpos,STAT=istat)
   !---------------------------------------------------------------------
end subroutine getLatLon


!/**
function getGridId(dlalo,ni,nj) result(gridId)
   implicit none
   integer :: ni,nj
   real :: dlalo
   integer :: gridId
!**/
   character(len=2), parameter :: gridType='L '
   real, parameter :: CENTER_LAT = 0.
   real, parameter :: CENTER_LON = 180.
   integer :: ig1,ig2,ig3,ig4
   real    :: lat0,lon0
   integer, external :: ezqkdef
   !---------------------------------------------------------------------
   lat0 = CENTER_LAT - dlalo*(real(nj)/2.)
   lon0 = CENTER_LON - dlalo*(real(ni)/2.)
   call cxgaig(gridType,ig1,ig2,ig3,ig4,lat0,lon0,dlalo,dlalo)
   gridId = ezqkdef(ni,nj,gridType,ig1,ig2,ig3,ig4,0)
   if (gridId<0) print *,'Error: ezqkdef'
   !---------------------------------------------------------------------
   return
end function getGridId
