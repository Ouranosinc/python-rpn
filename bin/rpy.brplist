#!/usr/bin/env python
#!/usr/bin/env python2
# -*- coding: utf-8 -*-
# Author: Stephane Chamberland <stephane.chamberland@canada.ca>
# Copyright: LGPL 2.1
"""
Show list of reports in a BURP file

Examples:
     rpy.brplist -i $ATM_MODEL_DFILES/bcmk_burp/2007021900.brp
"""
import sys
import argparse
import rpnpy.librmn.all as rmn


def print_list(inputFile, formatReport, matchIn, matchOut, formatBlock):
    """
    """
    funit  = rmn.burp_open(inputFile)

    #TODO: get select criterions from caller
    (lat, lon) = (-1, -1)

    for stnid in matchIn['stnid']:
        for idtyp in matchIn['idtyp']:
            for date in matchIn['date']:
                for time in matchIn['time']:
                    print_list1(funit, inputFile, formatReport, stnid, idtyp,
                                lat, lon, date, time, formatBlock,
                                matchIn, matchOut)
                    
    rmn.burp_close(funit)


def print_list1(funit, inputFile, formatReport, stnid, idtyp, lat, lon,
                date, time, formatBlock, matchIn, matchOut):
    """
    """        
    nbrp   = rmn.mrfnbr(funit)
    buf = None
    handle = 0
    
    #TODO: Print hedear format dependent
    ## print('0  MRFVOI  UNITE {0: >4}  NOM {1}'.format(funit, inputFile))
    ## #TODO: adjust with desired info
    ## print('0  STATION   LATI   LONG     DX     DY   FLGS(HEX)   DATE    TIME   IDTYP   NB_BLOCK   HANDLE')
    for irep in xrange(nbrp):
        try:
            handle = rmn.mrfloc(funit, handle, stnid, idtyp, lat, lon,
                                date, time)
        except:
            break
        buf    = rmn.mrfget(handle, buf, funit)
        params = rmn.mrbhdr(buf)
        params['handle'] = handle
        params['flgshex'] = hex(params['flgs'])
        params['flgsbin'] = ''.join(['1' if i else '0' for i in params['flgsl']])
        if formatReport:
            print(formatReport.format(**params))

        if formatBlock:
            for iblk in xrange(params['nblk']):
                bparams = rmn.mrbprm(buf, iblk+1)
                bparams['iblk'] = iblk+1
                bparams.update(params)
                isOk = True
                for k in matchIn.keys():
                    if (not k in ('stnid',)) and len(matchIn[k]) > 0 \
                        and matchIn[k] != [-1]:
                        if not bparams[k] in matchIn[k]:
                            isOk = False
                            break
                if isOk:
                    print(formatBlock.format(**bparams))

            
if __name__ == "__main__":
    default_format = ' {stnid:<9} {lat:>6} {lon:>6} {dx:>6} {dy:>6}  {flgshex:>8} {date:>8} {timehh:>2}h{timemm:>2} {idtyp:>6} {nblk:>10} {handle:>10}'
    default_format_blk = ' '*10+'{iblk:<6} {bfam:>6} {bdesc:>6} {btyp:>6} {nbit:>6} {bit0:>6} {datyp:>6} {nele:>3}x{nval:>2}x{nt}'
    #TODO: valid_keys desc
    valid_rep_keys = (
        'handle', 'stnid', 'time', 'timehh', 'timemm',
        'flgs', 'flgsl', 'flgshex', 'flgsbin', 'flgsd',
        'idtyp', 'idtypd',
        'ilat', 'ilon', 'idx', 'idy', 'lat', 'lon', 'dx', 'dy', 
        'ielev', 'elev', 'drnd', 'date', 'dateyy', 'datemm', 'datedd',
        'oars', 'runn', 'nblk', 'sup', 'nsup', 'xaux', 'nxaux'
        )
    valid_blk_keys = (
        'iblk', 'nele', 'nval', 'nt', 'bfam', 'bdesc', 'btyp', 'nbit',
        'bit0', 'datyp', 'datypd',
        'bknat', 'bknat_multi', 'bknat_kind', 'bknat_kindd',
        'bktyp', 'bktyp_alt', 'bktyp_kind', 'bktyp_kindd',
        'bkstp', 'bkstpd'
        )
        
    desc = "Show list of selected reports in a BURP file along with requested meta and stats."
    usage = """
    %(prog)s -i filename [options]
    """
    epilog = """-----\n
    --* Options are excluding records matching the provided value(s).
    ++* Options are selecting records matching the provided value(s).

    The default selection critera for all keys is a 'wildcard',
    i.e. all records are selected.

    Accepted format:
        Any python string.format() accepted string
        e.g: '{keyname:format}'
        warning: to print an actual '{' or '}' char
                 you'll need to specify '{{' or '}}' respectively

    Accepted keynames for reports and blocks:
        {}

    Accepted additional keynames for blocks only:
        {}

    Default formats:
        reports: '{}'
        blocks : '{}'
    """.replace('{','{{').replace('}','}}').replace('{{}}','{}')\
       .format('{'+'}  {'.join(valid_rep_keys)+'}',
               '{'+'}  {'.join(valid_blk_keys)+'}',
               default_format, default_format_blk)
    parser = argparse.ArgumentParser(
        description=desc, usage=usage, epilog=epilog,
        prefix_chars='-+', formatter_class=argparse.RawDescriptionHelpFormatter)
    
    ## group = parser.add_mutually_exclusive_group()

    parser.add_argument("-v", "--verbose",
                        action="count", default=0,
                        help="increase output verbosity")    
 
    parser.add_argument("-i", "--input", dest="inputFile",
                        nargs='+', required=True, type=str, default=[],
                        metavar='FILENAME',
                        help="Input RPN Std File name")

    parser.add_argument("-V", "--voir", dest="voir",
                        action="store_true",
                        help="Print BURP file the 'canonical' way with mrfvoi, ignore selectors and format")

    rgroup = parser.add_argument_group(title="Reports related options") #description='')

    rgroup.add_argument("-f", "--format", dest="formatReport",
                        type=str, default=default_format,
                        metavar="'"+default_format+"'",
                        help="Output Format")
    
    rgroup.add_argument("++stnid",  dest="f_stnid",
                        nargs='*', type=str, default=['*********'],
                        metavar='STNID',
                        help="Filter records by stnid values (9 char, use wildcad '*' for each char)")
    rgroup.add_argument("++date",  dest="f_date",
                        nargs='*', type=int, default=[-1],
                        metavar='YYYYMMDD',
                        help="Filter records by date [YYYYMMDD]")
    rgroup.add_argument("++time",  dest="f_time",
                        nargs='*', type=int, default=[-1],
                        metavar='HHMM',
                        help="Filter records by time [HHMM]")
    rgroup.add_argument("++idtyp",  dest="f_idtyp",
                        nargs='*', type=int, default=[-1],
                        metavar='IDTYP',
                        help="Filter records by idtyp [int]")

    pgroup = parser.add_argument_group(title="Blocks related options") #description='')
    pgroup.add_argument("-b", "--blocks", dest="listBlocks",
                        action="store_true",
                        help="List blocks for matching reports")
    pgroup.add_argument("--format_blk", dest="formatBlock",
                        type=str, default=default_format_blk,
                        metavar="'"+default_format_blk+"'",
                        help="Output Format for blocks")

    pgroup.add_argument("++datyp",  dest="f_datyp",
                        nargs='*', type=int, default=[-1],
                        metavar='DATYP',
                        help="Filter records by Data type [int]")
    pgroup.add_argument("++bfam",  dest="f_bfam",
                        nargs='*', type=int, default=[-1],
                        metavar='BFAM',
                        help="Filter records by Family block descriptor. (0-31) [int]")
    pgroup.add_argument("++bdesc",  dest="f_bdesc",
                        nargs='*', type=int, default=[-1],
                        metavar='BDESC',
                        help="Filter records by Block descriptor. (0-2047) [int]")
    #TODO: split btyp in 3: BKNAT, BKTYP, BKSTP
    pgroup.add_argument("++btyp",  dest="f_btyp",
                        nargs='*', type=int, default=[-1],
                        metavar='BTYP',
                        help="Filter records by Block type (0-2047) [int]")

    #TODO: lon, lat min/max filter

    args = parser.parse_args()

    rmn.mrfopt(rmn.FSTOP_MSGLVL, rmn.FSTOPS_MSG_FATAL)

    if args.voir:
        for myfile in args.inputFile:
            funit = rmn.fnom(myfile, rmn.FST_RO)
            rmn.mrfvoi(funit)
            rmn.fclos(funit)
        sys.exit(0)
        
    keylist = ('stnid', 'date', 'time', 'idtyp',
               'datyp', 'bfam', 'bdesc', 'btyp')
    (matchIn, matchOut) = ({}, {})
    formatBlock = args.formatBlock if args.listBlocks else ""
    
    for key in keylist:
        try:
            v = getattr(args,'f_'+key)
            if isinstance(v, str):
                matchIn[key] = [x.strip().lower() for x in v]
            else:
                matchIn[key] = v
        except:
            matchIn[key] = []
        try:
            v = getattr(args,'f_'+key)
            if isinstance(v, str):
                matchOut[key] = [x.strip().lower() for x in v]
            else:
                matchOut[key] = v
        except:
            matchOut[key] = []

    for myfile in args.inputFile:
        print_list(myfile, args.formatReport, matchIn, matchOut, formatBlock)
    
        
# -*- Mode: C; tab-width: 4; indent-tabs-mode: nil -*-
# vim: set expandtab ts=4 sw=4:
# kate: space-indent on; indent-mode cstyle; indent-width 4; mixedindent off;
