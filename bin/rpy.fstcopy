#!/usr/bin/env python
#!/usr/bin/env python2
# -*- coding: utf-8 -*-
# Author: Stephane Chamberland <stephane.chamberland@canada.ca>
# Copyright: LGPL 2.1
"""
Copy selected records from one RPNStd file to another

Examples:
    rpy.fstcopy -i /home/ordenv/ssm-domains9/release/gem-data_4.2.0/gem-data_4.2.0_all/share/data/dfiles/bcmk/geophy.fst \
                -o toto.fst \
                ++nomvar '^^' '>>' ++ip1 2002 ++ip2 1001

"""
import sys
import argparse
import rpnpy.librmn.all as rmn
## from rpnpy.rpndate import *

def compare_meta(meta, matchIn, matchOut, verbose):
    """
    """
    keylist = ('nomvar', 'typvar', 'etiket', 'ip1', 'ip2', 'ip3', 'datev')
    for key in keylist:
        ## val = getattr(args,'f_'+key)
        val = matchIn[key] if key in matchIn.keys() else []
        metaval = meta[key].strip() if isinstance(meta[key], str) else meta[key]
        if not (len(val) == 0 or val[0] in (-1,' ') or metaval in val):
            if verbose > 1:
                print('{0} : No match for key {1}: {2} not in {3}'.\
                      format(meta['nomvar'],key,metaval,val))
            return False
        ## val = getattr(args,'e_'+key)
        val = matchOut[key] if key in matchOut.keys() else []
        metaval = meta[key].strip() if isinstance(meta[key], str) else meta[key]
        if len(val) > 0 and meta[key] in val:
            if verbose > 1:
                print('{0} : Matching exclude  key {1}: {2} in {3}'.\
                      format(meta['nomvar'],key,meta[key],val))
            return False
    return True


def select_meta(inFile, matchIn, matchOut, verbose):
    """
    """
    klist = []
    nomvarlist = matchIn['nomvar'] if 'nomvar' in matchIn.keys() else [' ']
    if len(nomvarlist) == 0: nomvarlist = [' ']
    for nomvar in nomvarlist:
        klist0 = rmn.fstinl(inFile, nomvar=nomvar)
        if verbose > 1:
            print('Found {0} records matching "{1}"'.\
                  format(len(klist0),nomvar))
        for key in klist0:
            meta = rmn.fstprm(key)
            if compare_meta(meta, matchIn, matchOut, verbose):
                klist.append(key)
    if len(klist) == 0:
        if verbose > 0:
            sys.stdout.write('No Matching records.\n')
        else:
            klist = sorted(list(set(klist)))
            if verbose > 0:
                sys.stdout.write('Found {0} matching records.\n'.format(len(klist)))
    return klist


def copy_rec(inFileId, outFileId, overwrite, matchIn, matchOut, verbose):
    """
    """
    try:
        klist = select_meta(inFileId, matchIn, matchOut, verbose)
        for key in klist:
            rec = rmn.fstluk(key)
            rmn.fstecr(outFileId, rec['d'], rec, rewrite=overwrite)
    except:
        sys.stderr.write('ERROR: Unknown problem copying records.\n')
        raise

    
def copy_rec_fname(inputFile, outputFile, overwrite, matchIn, matchOut, verbose):
    """
    """
    if verbose == 0:
        rmn.fstopt(rmn.FSTOP_MSGLVL,rmn.FSTOPI_MSG_CATAST)
        
    try:
        if verbose > 0:
            sys.stdout.write('Opening File(s): {0}.\n'.format(str(inputFile)))
        inFileId = rmn.fstopenall(inputFile, rmn.FST_RO)
    except:
        sys.stderr.write('ERROR: Problem opening the file: {0}\n'.\
                         format(str(inputFile)))
        raise
    try:
        if verbose > 0:
            sys.stdout.write('Opening File: {0}.\n'.format(outputFile))
        outFileId = rmn.fstopenall(outputFile, rmn.FST_RW)
    except:
        sys.stderr.write('ERROR: Problem opening the file: {0}\n'.\
                         format(outputFile))
        raise
            
    try:
        copy_rec(inFileId, outFileId, overwrite, matchIn, matchOut, verbose)
    except:
        sys.stderr.write('ERROR: Unknown problem copying records.\n')
        raise
    finally:
        if verbose > 0:
            sys.stdout.write('Closing Files.\n')
        rmn.fstcloseall(outFileId)
        rmn.fstcloseall(inFileId)


if __name__ == "__main__":

    desc="Copy selected records from RPNStd file(s) to another."
    epilog="-- Options are excluding records according the provided value(s).\n++ Options are selecting records according the provided value(s).\n\nThe default selection critera for all keys is a 'wildcard',\ni.e. all records are selected."
    usage = "%(prog)s -i inputFile -o outputFile [options]"
    parser = argparse.ArgumentParser(
        description=desc, usage=usage, epilog=epilog,
        prefix_chars='-+', formatter_class=argparse.RawDescriptionHelpFormatter)
    
    ## group = parser.add_mutually_exclusive_group()

    parser.add_argument("-v", "--verbose",
                        action="count", default=0,
                        help="increase output verbosity")
                        ## action="store_true")
                        ## action='append')
                        ##choices=xrange(5, 10)
    
 
    parser.add_argument("-i", "--input", dest="inputFile",
                        nargs='+', required=True, type=str, default=[],
                        help="Input RPN Std File name")
    parser.add_argument("-o", "--output", dest="outputFile",
                        nargs=1,   type=str, default='',
                        help="Output RPN Std File name")

    parser.add_argument("--no-overwrite", action="store_false",
                        dest="overwrite",
                        help="Do not overrite existing rec in out put file"+
                             " with same meta if any, default is to overwrite")

   
    parser.add_argument("++nomvar",  dest="f_nomvar",
                        nargs='*', type=str, default=[],
                        metavar='NOMVAR',
                        help="Filter records by nomvar values")
    parser.add_argument("++typvar",  dest="f_typvar",
                        nargs='*', type=str, default=[],
                        metavar='TYPVAR',
                        help="Filter records by typvar values")
    parser.add_argument("++etiket",  dest="f_etiket",
                        nargs='*', type=str, default=[],
                        metavar='ETIKET',
                        help="Filter records by etiket values")

    parser.add_argument("++ip1",  dest="f_ip1",
                        nargs='*', type=int, default=[],
                        metavar='IP1',
                        help="Filter records by ip1 values")
    parser.add_argument("++ip2",  dest="f_ip2",
                        nargs='*', type=int, default=[],
                        metavar='IP2',
                        help="Filter records by ip2 values")
    parser.add_argument("++ip3",  dest="f_ip3",
                        nargs='*', type=int, default=[],
                        metavar='IP3',
                        help="Filter records by ip3 values")

    parser.add_argument("++datev",  dest="f_datev",
                        nargs='*', type=int, default=[],
                        metavar='DATEV',
                        help="Filter records by Valid date (CMC date Stamp)")
    ## parser.add_argument("++vdatev", dest="f_vdatev",
    ##                     nargs='*', type=str, default=[],
    ##                     metavar='YYYYMMDD.hhmmss',
    ##                     help="Filter records by Valid date (YYYYMMDD.hhmmss)")

    parser.add_argument("--nomvar",  dest="e_nomvar",
                        nargs='*', type=str, default=[],
                        metavar='NOMVAR',
                        help="Filter out records by nomvar values")
    parser.add_argument("--typvar",  dest="e_typvar",
                        nargs='*', type=str, default=[],
                        metavar='TYPVAR',
                        help="Filter out records by typvar values")
    parser.add_argument("--etiket",  dest="e_etiket",
                        nargs='*', type=str, default=[],
                        metavar='ETIKET',
                        help="Filter out records by etiket values")
    
    parser.add_argument("--ip1",  dest="e_ip1",
                        nargs='*', type=int, default=[],
                        metavar='IP1',
                        help="Filter out records by ip1 values")
    parser.add_argument("--ip2",  dest="e_ip2",
                        nargs='*', type=int, default=[],
                        metavar='IP2',
                        help="Filter out records by ip2 values")
    parser.add_argument("--ip3",  dest="e_ip3",
                        nargs='*', type=int, default=[],
                        metavar='IP3',
                        help="Filter out records by ip3 values")
    
    parser.add_argument("--datev",  dest="e_datev",
                        nargs='*', type=int, default=[],
                        metavar='DATEV',
                        help="Filter out records by Valid date (CMC date Stamp)")
    ## parser.add_argument("--vdatev", dest="e_vdatev",
    ##                     nargs='*', type=str, default=[],
    ##                     metavar='YYYYMMDD.hhmmss',
    ##                     help="Filter out records by Valid date (YYYYMMDD.hhmmss)")

    args = parser.parse_args()
    
    keylist = ('nomvar', 'typvar', 'etiket', 'ip1', 'ip2', 'ip3', 'datev')
    (matchIn, matchOut) = ({}, {})
    for key in keylist:
        try:
            matchIn[key] = getattr(args,'f_'+key)
        except:
            matchIn[key] = []
        try:
            matchOut[key] = getattr(args,'e_'+key)
        except:
            matchOut[key] = []
        if args.verbose > 1:
            print('Selecting {0:6s} in:{1:10s}, out:{2}'.format(key,str(matchIn[key]),str(matchOut[key])))

    try:
        copy_rec_fname(args.inputFile, args.outputFile, args.overwrite,
                       matchIn, matchOut, args.verbose)
    except:
        raise
        sys.exit(1)
        
# -*- Mode: C; tab-width: 4; indent-tabs-mode: nil -*-
# vim: set expandtab ts=4 sw=4:
# kate: space-indent on; indent-mode cstyle; indent-width 4; mixedindent off;
