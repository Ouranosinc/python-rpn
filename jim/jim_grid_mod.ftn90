!--------------------------------------------------------------------------
! This is free software, you can use/redistribute/modify it under the terms of
! the EC-RPN License v2 or any later version found (if not provided) at:
! - http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html
! - EC-RPN License, 2121 TransCanada, suite 500, Dorval (Qc), CANADA, H9P 1J3
! - service.rpn@ec.gc.ca
! It is distributed WITHOUT ANY WARRANTY of FITNESS FOR ANY PARTICULAR PURPOSE.
!--------------------------------------------------------------------------
!/**
module jim_grid_mod
   use vect_mod
   implicit none
   #include "../utils/rmnlib_basics.hf"
   #include "../utils/vect_mod.hf"
   #include "jim_const.hf"
   #include "jim_grid_mod.hf"
   private
   !@objective Compute grid on the Icosahedron grid
   !@public_functions
   public :: jim_grid_init,jim_grid_post_init,jim_tile_size,jim_approx_dx,jim_grid_finalize
   public :: jim_lat_lon,jim_lat_lon_nompi
   public :: grid_nodes_iter !REM: public for testing only
   !@public_params
   integer, parameter,public :: N_ICO_TILES = JIM_NGRIDS
   integer, parameter,public :: N_ICO_NODES = 12
   integer, parameter,public :: N_ICO_FACES = 20
   real,    parameter,public :: EARTH_RADIUS = JIM_EARTH_RADIUS_4
   real(RDOUBLE), parameter,public :: EARTH_RADIUS_8 = JIM_EARTH_RADIUS_8
   !@public_vars
   integer,save,public :: m_nij  = 0
   integer,save,public :: m_imin = 1
   integer,save,public :: m_jmin = 1
   integer,save,public :: m_imax = 1
   integer,save,public :: m_jmax = 1
   integer,save,public :: m_ncol = 1
   integer,save,public :: m_nrow = 1
   integer,save,public :: m_ngrids = 1
   integer,save,public :: m_icol = 0
   integer,save,public :: m_irow = 0
   integer,save,public :: m_igrid = 0

   type(vect_3d_8), pointer,save,public :: m_nodes_8(:,:,:)
!**/

!!$   #include <gmm.hf>
!!$   #include <WhiteBoard.hf>

   integer, parameter :: NIJ0 = 2
   integer, parameter :: N_TILES =  N_ICO_TILES

   integer,parameter :: NODES_NB_0(NIJ0,NIJ0,N_TILES) = reshape( (/ &
         2,  7,   1,  3, &
         7, 12,   3,  8, &
         3,  8,   1,  4, &
         8, 12,   4,  9, &
         4,  9,   1,  5, &
         9, 12,   5, 10, &
         5, 10,   1,  6, &
        10, 12,   6, 11, &
         6, 11,   1,  2, &
        11, 12,   2,  7  &
        /) , (/NIJ0,NIJ0,N_TILES/))

   integer,parameter,public :: JIM_DIJ(2,9,JIM_NTYPES) = reshape( (/ &
        !HEXAGONE
         6, 0, & !HEXAGONE nb edges
         0, 1, & !HEXAGONE repeated last point
         1, 1, &
         1, 0, &
         0,-1, &
        -1,-1, &
        -1, 0, &
         0, 1, &
         1, 1, & !HEXAGONE repeated first point
        !PENTAGONE [pt 1,1]
         5, 0, & !PENTAGONE nb edges
         0, 1, & !PENTAGONE repeated last point
         1, 1, &
         1, 0, &
         0,-1, &
        -1, 0, &
         0, 1, &
         1, 1, & !PENTAGONE repeated first point
         0, 0, & !dummy
        !NPOLE
         5, 0, & !NPOLE nb edges
         0, 1, & !NPOLE repeated last point
         1, 1, &
         1, 0, &
         0,-1, &
        -1,-1, &
         0, 1, &
         1, 1, & !NPOLE repeated first point
         0, 0, & !dummy
        !SPOLE
         5, 0, & !NPOLE nb edges
         0, 1, & !SPOLE repeated last point
         1, 1, &
         1, 0, &
        -1,-1, &
        -1, 0, &
         0, 1, &
         1, 1, & !SPOLE repeated first point
         0, 0  & !dummy
         /) , (/2,9,JIM_NTYPES/))

!!$   real(8), parameter :: pi_8 = dacos(-1.D0)

   logical,save :: m_init_L = .false. ,m_init2_L = .false.
   integer,save,public :: m_ndiv = -1

   interface jim_grid_post_init
      module procedure jim_grid_post_init_mpi
      module procedure jim_grid_post_init_nompi
   end interface

contains


   !/**
   function jim_grid_init(F_ni,F_nj,F_halox,F_haloy,F_periodx,F_periody,F_ndiv) result(F_istat)
      implicit none
      !@objective
      !@arguments
      integer, intent(out) :: F_ni,F_nj       !Ico Tile Grid dims
      integer, intent(out) :: F_halox,F_haloy ! Ico Tile Halo Dims
      logical, intent(out) :: F_periodx,F_periody ! Ico Grid Periodicity
      integer, intent(in)  :: F_ndiv
      !@return
      integer :: F_istat
      !@author Stephane Chamberland, July 2008
      !@description
      !
   !**/
      integer :: istat,G_ni,G_nj,G_halox,G_haloy
      !---------------------------------------------------------------------
      !print *,'[begin] jim_grid_init'
      !call flush()
      F_istat = RMN_OK
      if (m_init_L) return
      m_init_L = .true.
!!$      istat = wb_get('Grd_ico_ndiv',m_ndiv) !from grid param namelist
      m_ndiv = F_ndiv
      F_ni = jim_tile_size(m_ndiv) - 1 !G_ni
      F_nj = F_ni                      !G_nj
      F_halox = 2
      F_haloy = 2
      F_periodx = .false.
      F_periody = .false.

      !print *,'JIM grid approx dx,area:',jim_approx_dx(),jim_approx_area()

      !TODO: check that F_ni == F_nj
      !TODO: check that npx == npy
      !print *,'[end] jim_grid_init'
      !call flush()
      !---------------------------------------------------------------------
      return
   end function jim_grid_init


   !/**
   function jim_grid_post_init_nompi(F_imin,F_imax,F_jmin,F_jmax,F_ni,F_nj) result(F_istat)
      implicit none
      !@objective
      !@arguments
      integer, intent(in) :: F_imin,F_imax,F_jmin,F_jmax !- IcoTile dims
      integer, intent(in) :: F_ni,F_nj                   !- Computational Dims
      !@return
      integer :: F_istat
      !@author Stephane Chamberland, July 2008
      !@description
      !
   !**/
      integer :: istat,i,j,itmp,igrid
      real    :: rtmp
      type(vect_3d_8), pointer :: l_nodes_8(:,:)
      !---------------------------------------------------------------------
      F_istat = RMN_ERR
      if (.not.m_init_L) return

      F_istat = RMN_OK
      if (m_init2_L) return
      m_init2_L = .true.

      if (F_ni /= F_nj) then
         F_istat = RMN_ERR
         print *,'ERROR: ni != nj :',F_ni,F_nj
         call flush()
      endif
      if (F_imin > -1 .or. F_imax < F_ni+2 .or. F_jmin > -1 .or. F_jmax < F_nj+2) then
         F_istat = RMN_ERR
         print *,'ERROR: wrong halo size, min/max:',F_imin,F_imax,':',-1,F_ni+2
         print *,'ERROR: wrong halo size, min/max:',F_jmin,F_jmax,':',-1,F_nj+2
         call flush()
      endif

      m_imin = F_imin
      m_jmin = F_jmin
      m_imax = F_imax
      m_jmax = F_jmax
      m_ncol = 1
      m_nrow = 1
      m_ngrids = JIM_NGRIDS
      m_igrid = 0
      m_icol = 0
      m_irow = 0
      m_nij = F_ni !set m_nij as l_ni as returned by rpn_comm_topo()

      !- Compute basic nodes position
      allocate(m_nodes_8(F_imin:F_imax,F_jmin:F_jmax,0:m_ngrids-1),STAT=istat)
      F_istat = RMN_COMBINE_STATUS(F_istat,istat)
      allocate(l_nodes_8(F_imin:F_imax,F_jmin:F_jmax),STAT=istat)
      F_istat = RMN_COMBINE_STATUS(F_istat,istat)

      IF_OK: if (RMN_IS_OK(F_istat)) then

         do igrid = 0,m_ngrids-1
!!$            l_nodes_8 => m_nodes_8(:,:,igrid)
            call grid_nodes_iter(l_nodes_8,igrid,1,0,0)
            !- Put a non harmful value in m_nodes(0,0), this value should not be used but computations are made with it (then discarded) for simplicity
            m_nodes_8(0,0,igrid) = m_nodes_8(1,1,igrid)
            do j=F_jmin,F_jmax
               do i=F_imin,F_imax
                  m_nodes_8(i,j,igrid) = l_nodes_8(i,j)
               enddo
            enddo
!!$            print '(A5,I3,I3,3F)','init ',igrid,0,m_nodes_8(1,1,igrid)
!!$            if (igrid==0) print '(A5,I3,I3,3F)','initN',igrid,0,m_nodes_8(1,m_nij+1,igrid)
!!$            if (igrid==1) print '(A5,I3,I3,3F)','initS',igrid,0,m_nodes_8(m_nij+1,1,igrid)

         enddo
         !TODO: halo xch

      endif IF_OK

      deallocate(l_nodes_8,STAT=istat)

      !print *,'[end] jim_grid_post_init'
      call flush()

      !---------------------------------------------------------------------
      return
   end function jim_grid_post_init_nompi


   !/**
   function jim_grid_post_init_mpi(F_imin,F_imax,F_jmin,F_jmax,F_ni,F_nj,F_npx,F_npy,F_igrid,F_col,F_row) result(F_istat)
      implicit none
      !@objective
      !@arguments
      integer, intent(in) :: F_imin,F_imax,F_jmin,F_jmax !- IcoTile dims
      integer, intent(in) :: F_ni,F_nj                   !- Computational Dims
      integer, intent(in) :: F_npx,F_npy
      integer, intent(in) :: F_igrid
      integer, intent(in) :: F_col,F_row
      !@return
      integer :: F_istat
      !@author Stephane Chamberland, July 2008
      !@description
      !
   !**/
      integer :: istat,i,j,itmp
      real    :: rtmp
      type(vect_3d_8), pointer :: l_nodes_8(:,:)
!!$      real, pointer, dimension(:,:) :: lat,lon
!!$      type(gmm_metadata) :: gmmmeta
!!$      type(gmm_layout)   :: layout(4)
      !---------------------------------------------------------------------
      F_istat = RMN_ERR
      if (.not.m_init_L) return

      F_istat = RMN_OK
      if (m_init2_L) return
      m_init2_L = .true.

      !print *,'[begin] jim_grid_post_init'
      !call flush()

      !TODO: check F_igrid,F_col,F_row values

      if (F_ni /= F_nj) then
         F_istat = RMN_ERR
         print *,'ERROR: ni != nj :',F_ni,F_nj
         call flush()
      endif
      if (F_npx /= F_npy) then
         F_istat = RMN_ERR
         print *,'ERROR: npx != npy :',F_npx,F_npy
         call flush()
      endif
      if (F_imin > -1 .or. F_imax < F_ni+2 .or. F_jmin > -1 .or. F_jmax < F_nj+2) then
         F_istat = RMN_ERR
         print *,'ERROR: wrong halo size, min/max:',F_imin,F_imax,':',-1,F_ni+2
         print *,'ERROR: wrong halo size, min/max:',F_jmin,F_jmax,':',-1,F_nj+2
         call flush()
      endif
      !TODO: remove this test when grid_nodes_iter implements node calculation for npex!=2^n
      rtmp = log(real(F_npx))/log(2.)
      itmp = nint(rtmp)
      if (abs(rtmp-real(itmp))>1.e-5) then
         F_istat = RMN_ERR
         print *,'ERROR: npx != 2^n :',F_npx,' [Not yet implemented]'
         call flush()
      endif

!       m_share_npole = (F_col==0       .and. F_row==F_npy-1 .and. mod(F_igrid,2)==0)
!       m_share_spole = (F_col==F_npx-1 .and. F_row==0       .and. mod(F_igrid,2)/=0)
!       m_has_npole = (F_col==0       .and. F_row==F_npy-1 .and. F_igrid==0)
!       m_has_spole = (F_col==F_npx-1 .and. F_row==0       .and. F_igrid==1)
!       m_has_penta = (F_col==0       .and. F_row==0)
!       m_is_side   = (F_col==0 .or. F_row==0 .or. F_col==F_npy .or. F_row==F_npy)

      m_imin = F_imin
      m_jmin = F_jmin
      m_imax = F_imax
      m_jmax = F_jmax
      m_ncol = F_npx
      m_nrow = F_npy
      m_igrid = F_igrid
      m_icol = F_col
      m_irow = F_row
      m_nij = F_ni !set m_nij as l_ni as returned by rpn_comm_topo()

      !- Compute basic nodes position
      allocate(m_nodes_8(F_imin:F_imax,F_jmin:F_jmax,1),STAT=istat)
      F_istat = RMN_COMBINE_STATUS(F_istat,istat)

      IF_OK: if (RMN_IS_OK(F_istat)) then
         l_nodes_8 => m_nodes_8(:,:,1)
         call grid_nodes_iter(l_nodes_8,F_igrid,F_npx,F_col,F_row)

!!$         F_istat = RMN_COMBINE_STATUS(F_istat,ico_comm_xch_halo2(m_nij,1,m_nodes_8))
         !- Put a non harmful value in m_nodes(0,0), this value should not be used but computations are made with it (then discarded) for simplicity
         if (JIM_HAS_PENTA(F_col,F_row)) then
            m_nodes_8(0,0,1) = m_nodes_8(1,1,1)
         endif

      endif IF_OK

      !print *,'[end] jim_grid_post_init'
      call flush()
      !---------------------------------------------------------------------
      return
   end function jim_grid_post_init_mpi


   !/**
   subroutine jim_grid_finalize()
      implicit none
      !@objective
      !@author Stephane Chamberland
      !@description
   !**/
      integer ::istat
      !---------------------------------------------------------------------
      m_ndiv = -1
      m_init_L  = .false.
      m_init2_L = .false.
      if (allocated(m_nodes_8)) deallocate(m_nodes_8,STAT=istat)
      !---------------------------------------------------------------------
      return
   end subroutine jim_grid_finalize


   !/**
   function jim_tile_size(F_ndiv) result(nij)
      implicit none
      !@objective
      !@arguments
      integer, intent(in),optional :: F_ndiv     !Number of division
      !@return
      integer :: nij                  !grid size
      !@author Stephane Chamberland
      !@revisions
      !  2008-06, Stephane Chamberland: Original Code
      !@description
   !**/
      integer :: ndiv2
      !---------------------------------------------------------------------
      ndiv2 = m_ndiv
      if (present(F_ndiv)) ndiv2 = F_ndiv
      nij = 2**ndiv2*(NIJ0-1)+1
      !---------------------------------------------------------------------
      return
   end function jim_tile_size


   !/**
   function jim_approx_dx(F_ndiv) result(dx_8)
      implicit none
      integer, intent(in),optional :: F_ndiv     !Number of division
      !@return
      real(RDOUBLE) :: dx_8           !Approx grid resolution [m]
      !@author Stephane Chamberland, 2008-06
      !@revisions
      !@description
   !**/
      real(RDOUBLE) :: pi_8
      integer :: ndiv2
      !---------------------------------------------------------------------
      ndiv2 = m_ndiv
      if (present(F_ndiv)) ndiv2 = F_ndiv
      pi_8 = dacos(-1.D0)
      dx_8 = EARTH_RADIUS_8 * dsqrt(4.D0*pi_8/dble(nb_vertices(ndiv2)))
      !---------------------------------------------------------------------
      return
   end function jim_approx_dx


   !/**
   function jim_approx_area(F_ndiv) result(aa_8)
      implicit none
      integer, intent(in),optional :: F_ndiv     !Number of division
      !@return
      real(RDOUBLE) :: aa_8           !Approx grid node area [m]
      !@author Stephane Chamberland, 2008-10
      !@revisions
      !@description
   !**/
      real(RDOUBLE) :: pi_8
      integer :: ndiv2
      !---------------------------------------------------------------------
      ndiv2 = m_ndiv
      if (present(F_ndiv)) ndiv2 = F_ndiv
      pi_8 = dacos(-1.D0)
      aa_8 = 4.D0*pi_8 *(EARTH_RADIUS_8**2.D0)/dble(nb_vertices(ndiv2))
      !---------------------------------------------------------------------
      return
   end function jim_approx_area


   !/**
   function jim_lat_lon(lat,lon) result(F_istat)
      implicit none
      !@objective
      !@arguments
      real, pointer, dimension(:,:) :: lat,lon !OUT
      !@return
      integer :: F_istat
      !@author Stephane Chamberland, 2008-08
      !@revisions
      !  2008-08, Stephane Chamberland: Original code
      !@description
   !**/
      integer :: i,j
      type(vect_3d_8) :: node_sph
      !---------------------------------------------------------------------
      F_istat = RMN_ERR
      if (.not.m_init2_L) return
      F_istat = RMN_OK

      do j=1,m_nij
         do i=1,m_nij
            node_sph = vect_car2sphd(m_nodes_8(i,j,1))
            lon(i,j) = real(node_sph%v(V_LMB))
            lat(i,j) = real(node_sph%v(V_PHI))
         enddo
      enddo

      !- poles
      if (JIM_HAS_NPOLE(m_igrid,m_icol,m_irow)) then
         lon(1,m_nij+1) = 0.
         lat(1,m_nij+1) = 90.
      endif
      if (JIM_HAS_SPOLE(m_igrid,m_icol,m_irow)) then
         lon(m_nij+1,1) = 0.
         lat(m_nij+1,1) = -90.
      endif
      !---------------------------------------------------------------------
      return
   end function jim_lat_lon


   !/**
   function jim_lat_lon_nompi(lat,lon) result(F_istat)
      implicit none
      !@objective
      !@arguments
      real, pointer, dimension(:,:,:) :: lat,lon !OUT
      !@return
      integer :: F_istat
      !@author Stephane Chamberland, 2008-08
      !@revisions
      !  2008-08, Stephane Chamberland: Original code
      !@description
   !**/
      integer :: i,j,igrid
      type(vect_3d_8) :: node_sph
      !---------------------------------------------------------------------
      F_istat = RMN_ERR
      if (.not.m_init2_L) return
      F_istat = RMN_OK

      do igrid = 0,m_ngrids-1
         do j=1,m_nij
            do i=1,m_nij
               node_sph = vect_car2sphd(m_nodes_8(i,j,igrid))
               lon(i,j,igrid) = real(node_sph%v(V_LMB))
               lat(i,j,igrid) = real(node_sph%v(V_PHI))
            enddo
         enddo

         !- poles
         if (JIM_HAS_NPOLE(igrid,m_icol,m_irow)) then
            lon(1,m_nij+1,igrid) = 0.
            lat(1,m_nij+1,igrid) = 90.
         endif
         if (JIM_HAS_SPOLE(igrid,m_icol,m_irow)) then
            lon(m_nij+1,1,igrid) = 0.
            lat(m_nij+1,1,igrid) = -90.
         endif
      enddo
      !---------------------------------------------------------------------
      return
   end function jim_lat_lon_nompi



   !==== Private functions =================================================

   !/**
   subroutine ico_initial_grid(F_nodes0_8)
      implicit none
      !@objective
      !@arguments
      type(vect_3d_8), intent(out) :: F_nodes0_8(N_ICO_NODES) !Nodes positions
      !@author J. Pudykiewicz - October 2001
      !@revisions
      !  2001-10, J. Pudykiewicz: original code
      !  2008-06, Stephane Chamberland: convert from MATLAB to F90
      !  2008-11, Stephane Chamberland: double precision output
      !@description
      !  Evaluation of nodes for the
      !  icosahedron used for triangulation of the unit sphere
      !
      !  Unfolded icosahedron points numbering
      !    1 1 1 1 1
      !   2 3 4 5 6 2
      !    7 8 9 A B 7
      !   C C C C C C
      !
      !  Unfolded icosahedron points numbering... put on a square grid
      !
      !                           1 2 | 2 7
      !                           6 B | B C
      !                           ---
      !                     1 6 | 6 B
      !                     5 A | A C
      !                     ---
      !               1 5 | 5 A
      !               4 9 | 9 C
      !               ---
      !         1 4 | 4 9
      !         3 8 | 8 C
      !         ---
      !   1 3 | 3 8
      !   2 7 | 7 C
      !
      !  ico-Tile numbering for the above
      !
      !                  8 | 9
      !                  -
      !              6 | 7
      !              -
      !          4 | 5
      !          -
      !      2 | 3
      !      -
      !  0 | 1
      !
   !**/
      integer :: i,n,i0,in,i2
      real(RDOUBLE) :: theta0_8, lambda_8(N_ICO_NODES), theta_8(N_ICO_NODES), tmp_8
      real(RDOUBLE) :: pi_8
      !---------------------------------------------------------------------
!!$      print *,'[begin] ico_initial_grid'
!!$      call flush()
      pi_8     = dacos(-1.D0)
      theta0_8 = 2.D0 * dacos( 1.D0/( 2.D0*dcos(3.D0*pi_8/10.D0) ) ) - pi_8/2.D0

      tmp_8 = 2.D0*pi_8/5.D0

      !- 1st Point: North pole
      i = 1
      lambda_8(i) = 0.D0
      theta_8(i)  = 0.5D0*pi_8

      !- Northern hemisphere points
      do n=1,5
         i  = i + 1
         lambda_8(i) = (dble(n-1)-0.5D0)*tmp_8
         theta_8(i)  = -theta0_8
      enddo

      !- Southern hemisphere points
      do n=1,5
         i  = i + 1
         lambda_8(i) = dble(n-1)*tmp_8
         theta_8(i)  = theta0_8
     enddo

      !- Last Point: South pole
      lambda_8(N_ICO_NODES) = 0.D0
      theta_8(N_ICO_NODES)  = -0.5D0*pi_8

      !- Cartesian coor
      do i=1,N_ICO_NODES
         F_nodes0_8(i)%v(3) = dsin(theta_8(i))
         F_nodes0_8(i)%v(2) = dcos(theta_8(i))*dsin(lambda_8(i))
         F_nodes0_8(i)%v(1) = dcos(theta_8(i))*dcos(lambda_8(i))
      enddo
!!$      print *,'[end] ico_initial_grid'
!!$      call flush()
      !---------------------------------------------------------------------
      return
   end subroutine ico_initial_grid


   !/**
   function nb_vertices(F_ndiv) result(nvertices)
      implicit none
      !@objective
      !@arguments
      integer, intent(in),optional :: F_ndiv    !Number of division
      !@return
      integer(IDOUBLE) :: nvertices    !Number of vertices
      !@author Stephane Chamberland
      !@revisions
      !  2008-06, Stephane Chamberland: Original Code
      !@description
   !**/
      integer(IDOUBLE), parameter :: TWO_8         = 2_IDOUBLE
      integer(IDOUBLE), parameter :: N_ICO_FACES_8 = 20_IDOUBLE
      integer(IDOUBLE) :: nfaces_8, ndiv_8
      !---------------------------------------------------------------------
      ndiv_8 = m_ndiv
      if (present(F_ndiv)) ndiv_8 = F_ndiv
      nfaces_8  = N_ICO_FACES
      nvertices = (TWO_8**(TWO_8*ndiv_8)*nfaces_8)/TWO_8+TWO_8
      !---------------------------------------------------------------------
      return
   end function nb_vertices


   !/**
   subroutine grid_nodes_iter(F_nodes_8,F_ico_tile,F_npexy,F_col,F_row)
      implicit none
      !@objective
      !@arguments
      type(vect_3d_8), pointer  :: F_nodes_8(:,:) !Nodes positions [out]
      integer,       intent(in) :: F_ico_tile   !Ico Tile Number [0-9]
      integer,       intent(in) :: F_npexy      !Number of PE along x/y per ico-tile
      integer,       intent(in) :: F_col,F_row  !x/y PE Position of in the ico-tile [0,npexy-1]
      !@author J. Pudykiewicz - December 2007
      !@revisions
      !  2007-12, J. Pudykiewicz: original code
      !  2008-06, Stephane Chamberland: convert from MATLAB to F90
      !  2008-07, Stephane Chamberland: MPI-ify [2 steps: global then local]
      !  2008-11, Stephane Chamberland: nodes now on unit sphere
      !  2008-11, Stephane Chamberland: double precision
      !@description
    !**/
      type(vect_3d_8) :: nodes0_8(N_ICO_NODES)
      type(vect_3d_8),pointer :: nodes_8(:,:)
!!$      type(vect_3d) :: node2(2)
      integer :: i,j,i2,j2,nij,ndiv1,istat
      real    :: rndiv1
      !---------------------------------------------------------------------
!!$      print *,'[begin] grid_nodes_iter'
!!$      call flush()
      !---- First divisions pass up to ndiv1 = ln(npexy)/ln(2), from Icoshedron
      if (F_npexy>1) then
         rndiv1 = log(float(F_npexy))/log(2.)
         ndiv1  = ceiling(rndiv1)
      else
         ndiv1 = 0
      endif
!!$      print *,'ndiv',rndiv1,ndiv1,m_ndiv,m_ndiv - ndiv1
      !TODO: error if ndiv1 /= floor(rndiv1)
      !TODO: if (ndiv1 > ndiv) error

      !- TODO: ERROR if F_ico_tile >= N_TILES or <0
      call ico_initial_grid(nodes0_8)
      nij = jim_tile_size(ndiv1)
      allocate(nodes_8(nij,nij),STAT=istat)
!!$      call handle_error(istat,'grid_nodes_iter: mem alloc failed')
      do j=1,NIJ0
         do i=1,NIJ0
            nodes_8(i,j) = vect_normalize(nodes0_8(NODES_NB_0(i,j,F_ico_tile+1)))
         enddo
      enddo
!!$      print '(A4,I3,I3,3F)','iter ',F_ico_tile,NODES_NB_0(1,1,F_ico_tile+1),nodes0_8(NODES_NB_0(1,1,F_ico_tile+1))
!!$      print '(A4,I3,I3,3F)','iter ',F_ico_tile,NODES_NB_0(1,1,F_ico_tile+1),nodes_8(1,1)

!!$      print '(A5,I3,I3,3F)','iterN',F_ico_tile,NODES_NB_0(1,2,F_ico_tile+1),nodes_8(1,2)
!!$      print '(A5,I3,I3,3F)','iterS',F_ico_tile,NODES_NB_0(2,1,F_ico_tile+1),nodes_8(2,1)

      if (ndiv1>0) then
!!$         print 'A,I6,A,2I6','grid_div_iter 1st pass:',ndiv1,':',size(nodes_8)
!!$         call flush()
         call grid_div_iter(nodes_8,ndiv1)
      endif

      !---- Second division pass up to ndiv, from 1st pass
      !- TODO: ERROR if (lbound(F_nodes_8,1) > 1)
      !- TODO: ERROR if (lbound(F_nodes_8,2) > 1)
      !- TODO: ERROR if (ubound(F_nodes_8,1) < jim_tile_size(m_ndiv - ndiv1))
      !- TODO: ERROR if (ubound(F_nodes_8,2) < jim_tile_size(m_ndiv - ndiv1))

      j2 = F_row
      do j=1,2
         j2 = j2 + 1
         i2 = F_col
         do i=1,2
            i2 = i2 + 1
            F_nodes_8(i,j) = nodes_8(i2,j2)
         enddo
      enddo
!!$      print '(A4,I3,I3,3F)','iter ',i2,j2,F_nodes_8(1,1)

!!$      print '(A5,I3,I3,3F)','iterN',-1,1,F_nodes_8(1,2)
!!$      print '(A5,I3,I3,3F)','iterS',-1,1,F_nodes_8(2,1)

      deallocate(nodes_8,STAT=istat)

      if (m_ndiv - ndiv1>0) then
!!$         print 'A,I6,A,2I6','grid_div_iter 2nd pass:',m_ndiv - ndiv1,':',size(F_nodes_8)
!!$         call flush()
         call grid_div_iter(F_nodes_8,m_ndiv - ndiv1)
      endif
!!$      print '(A4,I3,I3,3F)','iter ',0,0,F_nodes_8(1,1)

!!$      print '(A5,I3,I3,3F)','iterN',-1,2,F_nodes_8(1,m_nij+1)
!!$      print '(A5,I3,I3,3F)','iterS',-1,2,F_nodes_8(m_nij+1,1)

!!$      print *,'[end] grid_nodes_iter'
!!$      call flush()
      !---------------------------------------------------------------------
      return
   end subroutine grid_nodes_iter


   !/**
   subroutine grid_div_iter(F_nodes_8,F_ndiv)
      implicit none
      !@objective
      !@arguments
      type(vect_3d_8), pointer    :: F_nodes_8(:,:) !Nodes positions [inout]
      integer,           intent(in) :: F_ndiv       !Number of division
      !@author J. Pudykiewicz - December 2007
      !@revisions
      !  2007-12, J. Pudykiewicz: original code
      !  2008-06, Stephane Chamberland: convert from MATLAB to F90
      !  2008-11, Stephane Chamberland: nodes now on unit sphere
      !  2008-11, Stephane Chamberland: double precision
      !@description
      !  Evaluate cartesian coordinates of the nodal points of
      !  the geodesic grid obtained after ndiv partions of icosahedron
      !
      !  The Original icosahedron on the sphere is split in 5x2 tiles,
      !  these tiles can be "deformed" as 5x2 square 2x2 grids
      !
      !  Grid/Tile rep. after doubling size + spreading original [o] points
      !  The grid being more like a lozange than a square one, see right panel
      !  o u o        o u o
      !  v x v         v x v
      !  o u o          o u o
      !
      ! F_nodes(1:2,1:2) are expected to contains grid corners value
      ! F_nodes dims are expected to be at least (1:n,1:n) where n=2**F_ndiv+1
  !**/
      integer :: i,j,i2,j2,nij,idiv
      !---------------------------------------------------------------------
!!$      print *,'[begin] grid_div_iter'
!!$      call flush()
!!$      print *,'F_nodes_8 2:',F_nodes_8(1:2,2)
!!$      call flush()
!!$      print *,'F_nodes_8 1:',F_nodes_8(1:2,1)
!!$      call flush()
      !- TODO: ERROR if (lbound(F_nodes_8,1) > 1)
      !- TODO: ERROR if (lbound(F_nodes_8,2) > 1)
      !- TODO: ERROR if (ubound(F_nodes_8,1) < jim_tile_size(F_ndiv))
      !- TODO: ERROR if (ubound(F_nodes_8,2) < jim_tile_size(F_ndiv))

      nij = NIJ0
      DIVLOOP: do idiv=1,F_ndiv
         !- Place an extra point between each point [spread o-points]
         do j=nij,1,-1
            j2 = j*2-1
            do i=nij,1,-1
               i2 = i*2-1
               F_nodes_8(i2,j2) = F_nodes_8(i,j)
            enddo
         enddo
         nij = 2*nij - 1

         !- New mid point, left/right average [u-points]
         do j=1,nij,2
            do i=2,nij,2
               F_nodes_8(i,j) =  vect_normalize( &
                    0.5D0*(F_nodes_8(i-1,j) + F_nodes_8(i+1,j)) &
                    )
            enddo
         enddo

         !- New mid point, top/bottom average [v-points]
         do j=2,nij,2
            do i=1,nij,2
               F_nodes_8(i,j) = vect_normalize( &
                    0.5D0*(F_nodes_8(i,j-1) + F_nodes_8(i,j+1)) &
                    )
            enddo
         enddo

         !- New mid point, bottom-left/top-right average [x-points]
         do j=2,nij,2
            do i=2,nij,2
               F_nodes_8(i,j) = vect_normalize( &
                    0.5D0*(F_nodes_8(i-1,j-1) + F_nodes_8(i+1,j+1)) &
                    )
            enddo
         enddo

      enddo DIVLOOP

!!$      print *,'[end] grid_div_iter'
!!$      call flush()
     !---------------------------------------------------------------------
      return
   end subroutine grid_div_iter


end module jim_grid_mod


!/**
function jim_grid_dims(F_ndiv,F_hashalo) result(F_nij)
   use jim_grid_mod,only:jim_tile_size
   implicit none
   !@objective
   !@arguments
   integer :: F_ndiv,F_hashalo              !intent(in)
   !@return
   integer :: F_nij
   !@author Stephane Chamberland, Sept 2009
   !@description
   !
!**/
   integer :: ndiv
   !---------------------------------------------------------------------
   ndiv  = min(max(0,F_ndiv),15)
   F_nij = jim_tile_size(ndiv)-1
   if(F_hashalo>0) F_nij = F_nij+2*2
   !---------------------------------------------------------------------
   return
end function jim_grid_dims


!/**
function jim_grid_lalo(F_lat,F_lon,F_nij,F_haloxy,F_ndiv) result(F_istat)
   use jim_grid_mod,only:jim_tile_size,jim_grid_init,jim_grid_post_init,jim_lat_lon_nompi,jim_grid_finalize,m_ndiv
   implicit none
   !@objective
   !@arguments
   integer :: F_nij,F_haloxy,F_ndiv               !intent(in)
   real, target, dimension(1-F_haloxy:F_nij+F_haloxy,1-F_haloxy:F_nij+F_haloxy,0:JIM_NGRIDS-1) :: F_lat,F_lon !intent(out)
   !@return
   integer :: F_istat
   !@author Stephane Chamberland, Sept 2009
   !@description
   !
!**/
   real, pointer, dimension(:,:,:) :: lat,lon !OUT
   integer :: nij,nijh,ni,nj,halox,haloy,ndiv,istat
   logical :: periodx,periody
   integer,external :: jim_xch_halo_nompi_2d_r4
   !---------------------------------------------------------------------
   ndiv  = min(max(0,F_ndiv),15)
   if (ndiv .ne. m_ndiv) then
      call jim_grid_finalize()
      !TODO: check that lat,lon size  and halo is compatible
      !nij = jim_tile_size(ndiv)
      !nij = lat,lon size, return init ni=nj=nij-1
      F_istat = jim_grid_init(ni,nj,halox,haloy,periodx,periody,ndiv)
      F_istat = jim_grid_post_init(1-halox,ni+halox,1-haloy,nj+haloy,ni,nj)
   endif
   F_lat = 0.
   F_lon = 0.
   lat => F_lat
   lon => F_lon
   F_istat = jim_lat_lon_nompi(lat,lon)
   nijh = ni+2*halox
   istat = jim_xch_halo_nompi_2d_r4(nijh,lat)
   istat = jim_xch_halo_nompi_2d_r4(nijh,lon)
!!$   call jim_grid_finalize()
   !---------------------------------------------------------------------
   return
end function jim_grid_lalo


!/**
function jim_grid_corners_lalo(F_c_lat,F_c_lon,F_nij,F_haloxy,F_ndiv) result(F_istat)
   use vect_mod
   use jim_grid_mod,only:JIM_DIJ,m_nodes_8,m_ndiv,jim_grid_init,jim_grid_post_init,jim_grid_finalize,m_nij,m_ncol,m_nrow
   implicit none
   !@objective
   !@arguments
   integer :: F_nij,F_haloxy,F_ndiv              !intent(in)
   real, target, dimension(6,1-F_haloxy:F_nij+F_haloxy,1-F_haloxy:F_nij+F_haloxy,0:JIM_NGRIDS-1) :: F_c_lat,F_c_lon !intent(out)
   !@return
   integer :: F_istat
   !@author Stephane Chamberland, Sept 2009
   !@description
   !
!**/
   integer, parameter :: ICOL=0,IROW=0
   integer :: nij,nijh,ni,nj,halox,haloy,ndiv,istat
   logical :: periodx,periody
   integer :: i,j,ig,ic,pt_type,ie2,je2,ie3,je3
   type(vect_3d_8) :: node0_8,node2_8,node3_8,mid_node,node_sph
   !---------------------------------------------------------------------
   F_istat = 0
   ndiv  = min(max(0,F_ndiv),15)
   if (ndiv .ne. m_ndiv) then
      call jim_grid_finalize()
      !TODO: check that lat,lon size  and halo is compatible
      !nij = jim_tile_size(ndiv)
      !nij = lat,lon size, return init ni=nj=nij-1
      F_istat = jim_grid_init(ni,nj,halox,haloy,periodx,periody,ndiv)
      F_istat = jim_grid_post_init(1-halox,ni+halox,1-haloy,nj+haloy,ni,nj)
   endif
   F_c_lat = 0.
   F_c_lon = 0.
   do ig=0,JIM_NGRIDS-1
      do j=1,F_nij
         do i=1,F_nij
            pt_type = JIM_HEXA
            if (JIM_IS_PENTA(i,j,ICOL,IROW)) then
               pt_type = JIM_PENTA
            else if (JIM_IS_NPOLE(i,j,ig,ICOL,IROW)) then
               pt_type = JIM_NPOLE
            else if (JIM_IS_SPOLE(i,j,ig,ICOL,IROW)) then
               pt_type = JIM_SPOLE
            endif
            node0_8 = m_nodes_8(i,j,ig)
            do ic=1,6
               if (ic == 6 .and. pt_type.ne.JIM_HEXA) then
                  F_c_lat(ic,i,j,ig) = F_c_lat(1,i,j,ig)
                  F_c_lon(ic,i,j,ig) = F_c_lat(1,i,j,ig)
               else
                  ie2 = JIM_NEXT_IJ(i,ic,JIM_EDGE_CENTER,pt_type,JIM_I)
                  je2 = JIM_NEXT_IJ(i,ic,JIM_EDGE_CENTER,pt_type,JIM_I)
                  ie3 = JIM_NEXT_IJ(i,ic,JIM_EDGE_RIGHT,pt_type,JIM_I)
                  je3 = JIM_NEXT_IJ(i,ic,JIM_EDGE_RIGHT,pt_type,JIM_I)
                  node2_8 = m_nodes_8(ie2,je2,ig)
                  node3_8 = m_nodes_8(ie3,je3,ig)
                  mid_node = vect_normalize((node0_8+node2_8+node3_8)/3.D0)
                  node_sph = vect_car2sphd(mid_node)
                  F_c_lat(ic,i,j,ig) = real(node_sph%v(V_PHI))
                  F_c_lon(ic,i,j,ig) = real(node_sph%v(V_LMB))
               endif
            enddo
         enddo
      enddo
   enddo
   !---------------------------------------------------------------------
   return
end function jim_grid_corners_lalo

!// kate: space-indent on; indent-mode cstyle; indent-width 3; mixedindent off;
